#pragma once

#include "./context.hpp"
#include "./init.hpp"

#include <neo/io/concepts/result.hpp>

#include <neo/buffer_sink.hpp>
#include <neo/buffer_source.hpp>
#include <neo/const_buffer.hpp>
#include <neo/dynbuf_io.hpp>
#include <neo/enum.hpp>
#include <neo/error.hpp>
#include <neo/mutable_buffer.hpp>
#include <neo/shifting_dynamic_buffer.hpp>
#include <neo/utility.hpp>

namespace neo::ssl {

namespace detail {

struct engine_impl;

inline void throw_error(std::error_code ec, std::string_view s) {
    if (ec) {
        throw std::system_error(ec, std::string(s));
    }
}

}  // namespace detail

struct ev_handshake {};

/**
 * HOW THIS WORKS:
 *
 * An engine<Input, Output> is templated on an 'Input' buffer_source and an
 * 'Output' buffer_sink. Rather than performing I/O, bytes are read/written to
 * these buffer outputs. These represent the read-end and write-end of a stream
 * connected to a peer.
 *
 * The engine_base has four abstract methods:
 *
 * - do_next_output(n) - Calls .prepare(n) on the Output and returns a single
 *   mutable_buffer. Data is copied from the internal engine into this output
 *   as that data is generated by the engine.
 * - do_next_input() - Calls .next() on the Input and returns a single
 *   const_buffer. The engine expects data from the peer to appear through the
 *   Input.
 * - do_commit_output(n) - Calls .commit(n) on the Output after the engine has
 *   written `n` bytes there.
 * - do_consume_input(n) - Calls .consume(n) on the Input after the engine is
 *   done with the next `n` bytes of data from the input stream.
 *
 * The engine<> template provides these four methods to fit with the input and
 * output types given to it.
 *
 * It is up to the caller to define how data is transmitted from 'Output' and
 * fed into 'Input'.
 */
class engine_base {
    friend struct neo::ssl::detail::engine_impl;

public:
    /**
     * @brief Perform an OpenSSL client-side handshake operation. This must be
     * called once before any other IO operations.
     *
     * @param ec Receives the error code of the operation.
     */
    void connect(std::error_code& ec) noexcept;
    void connect() {
        connect("Failure while initializing client-side SSL/TLS connection"_ec_throw);
    }

    /**
     * @brief Cleanly terminate the OpenSSL connection. Once run, no other IO
     * operation may be performed.
     *
     * @param ec Receives the error code of the operation.
     */
    void shutdown(std::error_code& ec) noexcept;
    void shutdown() { shutdown("Failure while shutting down SSL/TLS connection"_ec_throw); }

    /**
     * @brief Read from the decrypted plaintext stream into the given buffer.
     *
     * @param mb Destination of the read bytes.
     * @param ec Receives the error code of the operation.
     */
    basic_transfer_result read_some(mutable_buffer mb) noexcept;

    /**
     * @brief Feed the plaintext data into the engine.
     *
     * @param cb The data to write into the engine.
     */
    basic_transfer_result write_some(const_buffer cb) noexcept;

    bool needs_input() const noexcept;

private:
    void* _ssl_ptr = nullptr;
    void* _bio_ptr = nullptr;

    virtual void do_commit_output(std::size_t n)          = 0;
    virtual void do_consume_input(std::size_t n) noexcept = 0;

    virtual mutable_buffer do_next_output(std::size_t n) = 0;
    virtual const_buffer   do_next_input()               = 0;

protected:
    engine_base(context&);
    ~engine_base() { _free(); }
    engine_base(engine_base&& o) noexcept
        : _ssl_ptr(neo::take(o._ssl_ptr))
        , _bio_ptr(neo::take(o._bio_ptr)) {}

    engine_base& operator=(engine_base&& o) noexcept {
        _free();
        _ssl_ptr = neo::take(o._ssl_ptr);
        _bio_ptr = neo::take(o._bio_ptr);
        return *this;
    }
    void _free() noexcept;
};

/**
 * @brief An OpenSSL connection engine.
 *
 * Does not act on streams directly, but rather uses a buffer_source and a
 * buffer_sink to perform communication in a generic manner.
 *
 * The binary stream from the peer should be produced by the buffer_source,
 * and the binary stream generated by the engine will appear in the
 * buffer_sink, ready to be transmitted to the peer.
 */
template <buffer_source Input, buffer_sink Output>
class NEO_IO_OPENSSL_API_ATTR engine : public engine_base {
public:
    using input_type  = std::remove_cvref_t<Input>;
    using output_type = std::remove_cvref_t<Output>;

private:
    wrap_refs_t<Input>  _input;
    wrap_refs_t<Output> _output;

    void do_commit_output(std::size_t n) override { output().commit(n); }
    void do_consume_input(std::size_t n) noexcept override { input().consume(n); }

    mutable_buffer do_next_output(std::size_t n) override {
        auto next = output().prepare(n);
        return buffers_consumer{next}.next(n);
    }

    const_buffer do_next_input() override {
        auto next = input().next(1024);
        return buffers_consumer{next}.next(1024);
    }

public:
    /**
     * @brief Construct a new engine object from the given context, with default-constructed input
     * and output
     *
     * @param ctx A valid ssl::context. Must outlive the engine.
     */
    engine(context& ctx) noexcept
        : engine::engine_base(ctx) {}

    /**
     * @brief Construct a new engine object with a given context using the given input and output
     * streams
     *
     * @param ctx A valid ssl::context. Must outlive the engine.
     * @param in The buffer_source to copy/move/bind for the engine.
     * @param out The buffer_sink to copy/move/bind for the engine.
     */
    engine(context& ctx, Input&& in, Output&& out)
        : engine::engine_base(ctx)
        , _input(NEO_FWD(in))
        , _output(NEO_FWD(out)) {}

    /**
     * @brief Move-from an existing engine object, but use the two given input and outputs
     *
     * @param other An engine to move-from. The buffers from this engine are not used.
     * @param in The buffer_source to use
     * @param out The buffer_sink to use
     */
    engine(engine_base&& other, Input&& in, Output&& out)
        : engine::engine_base(std::move(other))
        , _input(NEO_FWD(in))
        , _output(NEO_FWD(out)) {}

    NEO_DECL_UNREF_GETTER(input, _input);
    NEO_DECL_UNREF_GETTER(output, _output);

    NEO_DECL_REF_REBINDER(rebind_input, Input, _input);
    NEO_DECL_REF_REBINDER(rebind_output, Output, _output);

    void*       ssl_c_ptr() noexcept { return _ssl_ptr; }
    const void* ssl_c_ptr() const noexcept { return _ssl_ptr; }
    void*       bio_c_ptr() noexcept { return _bio_ptr; }
    const void* bio_c_ptr() const noexcept { return _bio_ptr; }
};

template <buffer_source Input, buffer_sink Output>
explicit engine(context&, Input&&, Output &&) -> engine<Input, Output>;

}  // namespace neo::ssl
